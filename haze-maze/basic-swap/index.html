<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Haze Maze — Basic Swap · ARC-HM-001</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!--
    BLOCK 1 — SHELL & BRAND (LOCKED)
    CaveCode Arcade Planet · Haze-Maze Line
  -->
  <style>
    :root {
      --cc-bg: #020617;
      --cc-panel: #02081b;
      --cc-panel-soft: #0b1120;
      --cc-border: #1f2937;
      --cc-accent: #fb923c;
      --cc-text-main: #e5e7eb;
      --cc-text-soft: #9ca3af;

      --tile-radius: 0.45rem;
      --tile-gap: 0.25rem;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #111827 0, var(--cc-bg) 55%);
      color: var(--cc-text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.25rem 0.75rem 2.5rem;
    }

    .shell {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    header {
      width: 100%;
      background: linear-gradient(135deg, #020617, #030712);
      border-radius: 999px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.65);
      padding: 0.9rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    @media (min-width: 640px) {
      header {
        flex-direction: row;
        align-items: baseline;
        justify-content: space-between;
      }
    }

    .title-line {
      font-size: clamp(1rem, 2.2vw, 1.15rem);
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .title-line span {
      color: var(--cc-text-soft);
      font-weight: 500;
    }

    .meta-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.15rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--cc-text-soft);
    }

    .meta-pill {
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      border: 1px solid #1f2937;
      background: #020617;
    }

    .meta-pill.highlight {
      border-color: var(--cc-accent);
      color: var(--cc-accent);
    }

    main {
      background: radial-gradient(circle at top, #020617 0, #000 55%);
      border-radius: 1.5rem;
      border: 1px solid var(--cc-border);
      box-shadow: 0 26px 70px rgba(0, 0, 0, 0.75);
      padding: 1.25rem 1rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    @media (min-width: 768px) {
      main {
        padding: 1.75rem 1.5rem 1.75rem;
      }
    }

    .hud-header {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .hud-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .hud-sub {
      font-size: 0.8rem;
      color: var(--cc-text-soft);
    }

    .badge-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .badge {
      border-radius: 999px;
      border: 1px solid var(--cc-border);
      padding: 0.15rem 0.55rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--cc-text-soft);
    }

    .badge.tight {
      letter-spacing: 0.06em;
    }

    .metrics-row {
      margin-top: 0.45rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.55rem;
      align-items: center;
    }

    .metric {
      min-width: 80px;
      padding: 0.35rem 0.65rem;
      border-radius: 0.85rem;
      background: radial-gradient(circle at top left, #020617 0, #020617 40%, #000 100%);
      border: 1px solid var(--cc-border);
      display: flex;
      flex-direction: column;
      gap: 0.12rem;
      font-size: 0.7rem;
    }

    .metric span {
      color: var(--cc-text-soft);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.65rem;
    }

    .metric strong {
      font-size: 0.9rem;
      letter-spacing: 0.04em;
    }

    .metric.important strong {
      color: var(--cc-accent);
    }

    .metric-button-wrap {
      margin-left: auto;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid var(--cc-border);
      background: radial-gradient(circle at top, #020617 0, #000 100%);
      padding: 0.45rem 0.9rem;
      font-size: 0.7rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--cc-text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    .btn:hover {
      border-color: var(--cc-accent);
      color: var(--cc-accent);
    }

    .btn.secondary {
      border-style: dashed;
      opacity: 0.9;
    }

    .game-panel {
      margin-top: 0.75rem;
      border-radius: 1.25rem;
      border: 1px solid var(--cc-border);
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      padding: 0.9rem 0.8rem 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.9rem;
    }

    .board {
      width: min(82vw, 420px);
      aspect-ratio: 1 / 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: var(--tile-gap);
      padding: 0.55rem;
      border-radius: 1rem;
      background: radial-gradient(circle at top, #020617 0, #000 65%);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.85);
    }

    .tile {
      border: none;
      padding: 0;
      margin: 0;
      border-radius: var(--tile-radius);
      cursor: pointer;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.45);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, filter 0.08s ease-out;
    }

    .tile:focus-visible {
      outline: 2px solid var(--cc-accent);
      outline-offset: 2px;
    }

    .tile.selected {
      transform: translateY(-2px);
      box-shadow: 0 0 0 3px #facc15, 0 8px 16px rgba(0, 0, 0, 0.8);
      filter: brightness(1.1);
    }

    .tile.blank {
      opacity: 0;
      pointer-events: none;
    }

    .status-block {
      max-width: 480px;
      font-size: 0.8rem;
      color: var(--cc-text-soft);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .status-main {
      font-size: 0.8rem;
    }

    .status-main span {
      color: var(--cc-accent);
      font-weight: 600;
    }

    footer {
      margin-top: 0.2rem;
      font-size: 0.75rem;
      color: var(--cc-text-soft);
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div>
        <div class="title-line">
          HAZE MAZE — BASIC SWAP · <span>ARC-HM-001</span>
        </div>
        <div class="meta-line">
          <div class="meta-pill">CaveCode Arcade Planet</div>
          <div class="meta-pill">Haze-Maze Line</div>
          <div class="meta-pill">Match-3 Grid</div>
          <div class="meta-pill highlight" id="meta-level-pill">Level 1</div>
        </div>
      </div>
    </header>

    <main>
      <section class="hud-header">
        <div class="hud-title">Tap two adjacent tiles to swap. Make a match of 3+ to clear.</div>
        <div class="hud-sub" id="objective-text">
          Level 1 · Reach 500 points in 20 moves.
        </div>

        <div class="badge-row">
          <div class="badge">8×8 Board</div>
          <div class="badge">Single-file Engine</div>
          <div class="badge tight">CaveCode v1 Blocks</div>
        </div>

        <div class="metrics-row">
          <div class="metric important">
            <span>Level</span>
            <strong id="level-num">1</strong>
          </div>
          <div class="metric">
            <span>Score</span>
            <strong id="score-val">0</strong>
          </div>
          <div class="metric">
            <span>Target</span>
            <strong id="target-val">500</strong>
          </div>
          <div class="metric">
            <span>Moves Left</span>
            <strong id="moves-val">20</strong>
          </div>
          <div class="metric">
            <span>Last Clear</span>
            <strong id="last-clear-val">0</strong>
          </div>
          <div class="metric-button-wrap">
            <button class="btn" id="restart-btn" type="button">
              ↻ Restart Level
            </button>
          </div>
        </div>
      </section>

      <section class="game-panel">
        <div class="board" id="board"></div>

        <div class="status-block">
          <div class="status-main" id="status-line">
            Reach <span>500</span> points before you run out of moves.
          </div>
          <div>
            <button class="btn secondary" id="next-level-btn" type="button" style="display:none;">
              ➜ Next Level
            </button>
          </div>
        </div>
      </section>

      <footer>
        Forged in CaveCode Arcade Planet · SageWire Syndicate
      </footer>
    </main>
  </div>

  <!--
    BLOCK 2 — CORE LOOP SUMMARY (LOCKED)
    Tick = player swap:
      • Attempt swap
      • If adjacent → swap tiles
      • If match exists → clear, drop new tiles, add score
      • Decrease moves, check win / lose
  -->
  <script>
    // BLOCK 3 — TUNING KNOBS (SAFE TO EDIT)
    const BOARD_SIZE = 8;
    const COLORS = ["#fb923c", "#22c55e", "#3b82f6", "#a855f7", "#facc15"];

    // Level table: tweak targets and moves here.
    const LEVELS = [
      { target: 500, moves: 20 },
      { target: 1200, moves: 24 },
      { target: 2200, moves: 26 },
      { target: 3400, moves: 28 },
      { target: 5000, moves: 30 }
    ];

    // BLOCK 4 — STATE
    let board = [];
    let selected = null; // {row, col}
    let score = 0;
    let lastClearCount = 0;
    let movesLeft = 0;
    let currentLevelIndex = 0;
    let inputLocked = false;

    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score-val");
    const lastClearEl = document.getElementById("last-clear-val");
    const movesEl = document.getElementById("moves-val");
    const levelEl = document.getElementById("level-num");
    const targetEl = document.getElementById("target-val");
    const restartBtn = document.getElementById("restart-btn");
    const nextLevelBtn = document.getElementById("next-level-btn");
    const statusLine = document.getElementById("status-line");
    const objectiveText = document.getElementById("objective-text");
    const metaLevelPill = document.getElementById("meta-level-pill");

    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function createEmptyBoard() {
      board = Array.from({ length: BOARD_SIZE }, () =>
        Array(BOARD_SIZE).fill(null)
      );
    }

    function generateBoardNoInitialMatches() {
      createEmptyBoard();
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          let color;
          do {
            color = randomColor();
          } while (
            (c >= 2 &&
              board[r][c - 1] === color &&
              board[r][c - 2] === color) ||
            (r >= 2 &&
              board[r - 1][c] === color &&
              board[r - 2][c] === color)
          );
          board[r][c] = color;
        }
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const tile = document.createElement("button");
          tile.className = "tile";
          tile.dataset.row = r;
          tile.dataset.col = c;
          tile.style.backgroundColor = board[r][c] || "transparent";
          if (!board[r][c]) {
            tile.classList.add("blank");
          }
          if (selected && selected.row === r && selected.col === c) {
            tile.classList.add("selected");
          }
          boardEl.appendChild(tile);
        }
      }
    }

    function setHUD() {
      const level = LEVELS[currentLevelIndex];
      levelEl.textContent = currentLevelIndex + 1;
      targetEl.textContent = level.target;
      scoreEl.textContent = score;
      lastClearEl.textContent = lastClearCount;
      movesEl.textContent = movesLeft;
      metaLevelPill.textContent = `Level ${currentLevelIndex + 1}`;
      objectiveText.textContent =
        `Level ${currentLevelIndex + 1} · Reach ${level.target} points in ${level.moves} moves.`;
      statusLine.innerHTML =
        `Reach <span>${level.target}</span> points before you run out of moves.`;
    }

    function startLevel(index) {
      currentLevelIndex = index;
      const level = LEVELS[currentLevelIndex];
      score = 0;
      lastClearCount = 0;
      movesLeft = level.moves;
      selected = null;
      inputLocked = false;
      nextLevelBtn.style.display = "none";
      generateBoardNoInitialMatches();
      renderBoard();
      setHUD();
    }

    function tilesAdjacent(a, b) {
      const dr = Math.abs(a.row - b.row);
      const dc = Math.abs(a.col - b.col);
      return (dr === 1 && dc === 0) || (dr === 0 && dc === 1);
    }

    function swapTiles(a, b) {
      const temp = board[a.row][a.col];
      board[a.row][a.col] = board[b.row][b.col];
      board[b.row][b.col] = temp;
    }

    function findMatches() {
      const toClear = Array.from({ length: BOARD_SIZE }, () =>
        Array(BOARD_SIZE).fill(false)
      );
      // Rows
      for (let r = 0; r < BOARD_SIZE; r++) {
        let runColor = board[r][0];
        let runStart = 0;
        for (let c = 1; c <= BOARD_SIZE; c++) {
          const color = c < BOARD_SIZE ? board[r][c] : null;
          if (color === runColor) continue;
          const runLength = c - runStart;
          if (runColor && runLength >= 3) {
            for (let k = runStart; k < c; k++) {
              toClear[r][k] = true;
            }
          }
          runColor = color;
          runStart = c;
        }
      }
      // Columns
      for (let c = 0; c < BOARD_SIZE; c++) {
        let runColor = board[0][c];
        let runStart = 0;
        for (let r = 1; r <= BOARD_SIZE; r++) {
          const color = r < BOARD_SIZE ? board[r][c] : null;
          if (color === runColor) continue;
          const runLength = r - runStart;
          if (runColor && runLength >= 3) {
            for (let k = runStart; k < r; k++) {
              toClear[k][c] = true;
            }
          }
          runColor = color;
          runStart = r;
        }
      }

      const matches = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (toClear[r][c]) {
            matches.push({ row: r, col: c });
          }
        }
      }
      return matches;
    }

    function applyGravityAndFill() {
      for (let c = 0; c < BOARD_SIZE; c++) {
        const column = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
          if (board[r][c]) column.push(board[r][c]);
        }
        while (column.length < BOARD_SIZE) {
          column.unshift(randomColor());
        }
        for (let r = 0; r < BOARD_SIZE; r++) {
          board[r][c] = column[r];
        }
      }
    }

    function resolveMatchesAndScore() {
      let totalCleared = 0;
      while (true) {
        const matches = findMatches();
        if (matches.length === 0) break;
        lastClearCount = matches.length;
        for (const m of matches) {
          board[m.row][m.col] = null;
        }
        totalCleared += matches.length;
        applyGravityAndFill();
      }
      if (totalCleared > 0) {
        score += totalCleared * 10;
      }
    }

    function checkLevelEnd() {
      const level = LEVELS[currentLevelIndex];
      if (score >= level.target) {
        inputLocked = true;
        statusLine.innerHTML =
          `Level ${currentLevelIndex + 1} cleared! You reached <span>${score}</span> points.`;
        nextLevelBtn.style.display = "inline-flex";
      } else if (movesLeft <= 0) {
        inputLocked = true;
        statusLine.innerHTML =
          `Out of moves. Target was <span>${level.target}</span> points. Tap Restart Level to try again.`;
      } else {
        statusLine.innerHTML =
          `Reach <span>${level.target}</span> points. Moves left: <span>${movesLeft}</span>.`;
      }
      setHUD();
    }

    function handleTileClick(evt) {
      if (inputLocked) return;
      const tile = evt.target.closest(".tile");
      if (!tile) return;
      const row = parseInt(tile.dataset.row, 10);
      const col = parseInt(tile.dataset.col, 10);
      if (!board[row][col]) return;

      const pos = { row, col };

      if (!selected) {
        selected = pos;
        renderBoard();
        return;
      }

      // Second click
      if (selected.row === pos.row && selected.col === pos.col) {
        // Deselect
        selected = null;
        renderBoard();
        return;
      }

      if (!tilesAdjacent(selected, pos)) {
        // Switch selection to new tile
        selected = pos;
        renderBoard();
        return;
      }

      // Attempt swap
      swapTiles(selected, pos);
      renderBoard();

      const matches = findMatches();
      movesLeft -= 1;

      if (matches.length === 0) {
        // No match: swap back, still costs a move
        swapTiles(selected, pos);
        renderBoard();
        lastClearCount = 0;
      } else {
        resolveMatchesAndScore();
        renderBoard();
      }

      selected = null;
      checkLevelEnd();
    }

    boardEl.addEventListener("click", handleTileClick);

    restartBtn.addEventListener("click", () => {
      startLevel(currentLevelIndex);
    });

    nextLevelBtn.addEventListener("click", () => {
      const nextIndex =
        currentLevelIndex + 1 < LEVELS.length ? currentLevelIndex + 1 : 0;
      startLevel(nextIndex);
    });

    // BLOCK 5 — BOOTSTRAP
    startLevel(0);
  </script>
</body>
</html>
