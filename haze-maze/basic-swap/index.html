<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Haze Maze ‚Äî Basic Swap (ARC-HM-001)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root {
      --bg: #020617;
      --panel: #0b1120;
      --border: #1f2937;
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --accent: #22c55e;
      --accent-soft: #4ade80;
      --danger: #f97373;

      --tile-1: #f97316;
      --tile-2: #22c55e;
      --tile-3: #3b82f6;
      --tile-4: #eab308;
      --tile-5: #ec4899;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-shell {
      max-width: 900px;
      margin: 0 auto;
      padding: 0.75rem 1rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    header {
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    header .sub {
      font-size: 0.75rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    #top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.8rem;
    }

    #score-panel {
      display: flex;
      gap: 0.5rem;
    }

    .pill {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.2rem 0.75rem;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    #game-frame {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, #0b1120 0, #020617 70%);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    #board-wrapper {
      margin: 0 auto;
      max-width: 420px;
      aspect-ratio: 1 / 1;
      background: radial-gradient(circle at top, #020617 0, #020617 65%);
      border-radius: 0.75rem;
      border: 1px solid rgba(15, 23, 42, 1);
      padding: 0.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #board {
      width: 100%;
      height: 100%;
      display: grid;
      gap: 4px;
      touch-action: manipulation;
    }

    .tile {
      border-radius: 0.4rem;
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.6),
                  0 4px 8px rgba(0, 0, 0, 0.45);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.12s ease-out;
    }

    .tile[data-v="1"] { background: var(--tile-1); }
    .tile[data-v="2"] { background: var(--tile-2); }
    .tile[data-v="3"] { background: var(--tile-3); }
    .tile[data-v="4"] { background: var(--tile-4); }
    .tile[data-v="5"] { background: var(--tile-5); }

    .tile.selected {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 0 0 2px #e5e7eb, 0 6px 10px rgba(0, 0, 0, 0.6);
    }

    .tile.clearing {
      opacity: 0.25;
      transform: scale(0.9);
    }

    #hint-text {
      font-size: 0.8rem;
      color: var(--text-soft);
      text-align: center;
    }

    #reset-btn {
      font-size: 0.8rem;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.1), rgba(15, 23, 42, 1));
      color: var(--text-main);
      cursor: pointer;
    }

    #reset-btn:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }

    @media (min-width: 768px) {
      header h1 { font-size: 1.2rem; }
      #hint-text { font-size: 0.85rem; }
    }
  </style>
</head>
<body>
  <div id="game-shell">
    <header>
      <h1>Haze Maze ‚Äî Basic Swap ¬∑ ARC-HM-001</h1>
      <div class="sub">
        <span>CaveCode Arcade Planet ¬∑ Haze-Maze Line</span>
        <span>Tap two adjacent tiles to swap. Make a match of 3+ to clear.</span>
      </div>
    </header>

    <main id="game-frame">
      <div id="top-row">
        <div id="score-panel">
          <div class="pill" id="score-pill">Score: <span id="scoreVal">0</span></div>
          <div class="pill" id="combo-pill">Last Clear: <span id="comboVal">0</span></div>
        </div>
        <button id="reset-btn">‚Üª New Board</button>
      </div>

      <div id="board-wrapper">
        <div id="board"></div>
      </div>

      <div id="hint-text">
        Click or tap a tile, then an adjacent tile.  
        If the swap makes a match, tiles clear and new ones fall.
      </div>
    </main>
  </div>

  <script>
    // ============================================================
    // üéöÔ∏è TUNING KNOBS (match the .cavecode spec)
    // ============================================================
    const TUNING = {
      gridRows: 8,
      gridCols: 8,
      tileTypes: 5,   // values 1..5
      clearScore: 10,
      comboBonus: 5,
      matchLength: 3
    };

    // ============================================================
    // üîß STATE
    // ============================================================
    const boardEl = document.getElementById("board");
    const scoreValEl = document.getElementById("scoreVal");
    const comboValEl = document.getElementById("comboVal");
    const resetBtn = document.getElementById("reset-btn");

    let grid = [];
    let selected = null;
    let score = 0;

    // ============================================================
    // üß† BOARD LOGIC
    // ============================================================
    function createEmptyGrid() {
      const g = [];
      for (let r = 0; r < TUNING.gridRows; r++) {
        g[r] = new Array(TUNING.gridCols).fill(0);
      }
      return g;
    }

    function randomTile() {
      return Math.floor(Math.random() * TUNING.tileTypes) + 1;
    }

    function generateInitialGrid() {
      grid = createEmptyGrid();
      // Fill while avoiding starting matches
      for (let r = 0; r < TUNING.gridRows; r++) {
        for (let c = 0; c < TUNING.gridCols; c++) {
          let val;
          do {
            val = randomTile();
            grid[r][c] = val;
          } while (createsMatchAt(r, c));
        }
      }
    }

    function inBounds(r, c) {
      return r >= 0 && r < TUNING.gridRows && c >= 0 && c < TUNING.gridCols;
    }

    function createsMatchAt(r, c) {
      const val = grid[r][c];
      if (!val) return false;

      // Horizontal check
      let count = 1;
      let cc = c - 1;
      while (cc >= 0 && grid[r][cc] === val) { count++; cc--; }
      cc = c + 1;
      while (cc < TUNING.gridCols && grid[r][cc] === val) { count++; cc++; }
      if (count >= TUNING.matchLength) return true;

      // Vertical check
      count = 1;
      let rr = r - 1;
      while (rr >= 0 && grid[rr][c] === val) { count++; rr--; }
      rr = r + 1;
      while (rr < TUNING.gridRows && grid[rr][c] === val) { count++; rr++; }
      return count >= TUNING.matchLength;
    }

    function findMatches() {
      const matches = [];
      // Horizontal
      for (let r = 0; r < TUNING.gridRows; r++) {
        let runVal = grid[r][0];
        let runStart = 0;
        for (let c = 1; c <= TUNING.gridCols; c++) {
          const val = c < TUNING.gridCols ? grid[r][c] : null;
          if (val === runVal && val !== 0) continue;
          const runLen = c - runStart;
          if (runVal !== 0 && runLen >= TUNING.matchLength) {
            for (let k = 0; k < runLen; k++) {
              matches.push({ r, c: runStart + k });
            }
          }
          runVal = val;
          runStart = c;
        }
      }

      // Vertical
      for (let c = 0; c < TUNING.gridCols; c++) {
        let runVal = grid[0][c];
        let runStart = 0;
        for (let r = 1; r <= TUNING.gridRows; r++) {
          const val = r < TUNING.gridRows ? grid[r][c] : null;
          if (val === runVal && val !== 0) continue;
          const runLen = r - runStart;
          if (runVal !== 0 && runLen >= TUNING.matchLength) {
            for (let k = 0; k < runLen; k++) {
              matches.push({ r: runStart + k, c });
            }
          }
          runVal = val;
          runStart = r;
        }
      }

      // Deduplicate
      const keySet = new Set();
      const unique = [];
      for (const m of matches) {
        const key = m.r + "," + m.c;
        if (!keySet.has(key)) {
          keySet.add(key);
          unique.push(m);
        }
      }
      return unique;
    }

    function applyMatches(matches) {
      if (!matches.length) return 0;
      // Score
      const clearedCount = matches.length;
      const comboBonus = clearedCount > TUNING.matchLength
        ? (clearedCount - TUNING.matchLength) * TUNING.comboBonus
        : 0;
      const gained = clearedCount * TUNING.clearScore + comboBonus;
      score += gained;
      scoreValEl.textContent = score;
      comboValEl.textContent = gained;

      // Clear tiles
      for (const m of matches) {
        grid[m.r][m.c] = 0;
      }

      // Gravity: for each column, collapse down
      for (let c = 0; c < TUNING.gridCols; c++) {
        let writeRow = TUNING.gridRows - 1;
        for (let r = TUNING.gridRows - 1; r >= 0; r--) {
          if (grid[r][c] !== 0) {
            grid[writeRow][c] = grid[r][c];
            if (writeRow !== r) {
              grid[r][c] = 0;
            }
            writeRow--;
          }
        }
        // Fill remaining rows at top
        for (let r = writeRow; r >= 0; r--) {
          grid[r][c] = randomTile();
        }
      }

      return gained;
    }

    // ============================================================
    // üé® RENDER / SELECTION
    // ============================================================
    function renderBoard() {
      const rows = TUNING.gridRows;
      const cols = TUNING.gridCols;
      boardEl.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      boardEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      boardEl.innerHTML = "";

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const val = grid[r][c];
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.dataset.r = r;
          tile.dataset.c = c;
          tile.dataset.v = val;
          boardEl.appendChild(tile);
        }
      }
    }

    function clearSelectionVisuals() {
      const tiles = boardEl.querySelectorAll(".tile.selected");
      tiles.forEach(t => t.classList.remove("selected"));
    }

    function markMatchesVisual(matches) {
      const set = new Set(matches.map(m => m.r + "," + m.c));
      const tiles = boardEl.querySelectorAll(".tile");
      tiles.forEach(t => {
        const r = parseInt(t.dataset.r, 10);
        const c = parseInt(t.dataset.c, 10);
        if (set.has(r + "," + c)) {
          t.classList.add("clearing");
        }
      });
    }

    // ============================================================
    // üéÆ INPUT HANDLING
    // ============================================================
    function areAdjacent(a, b) {
      if (!a || !b) return false;
      const dr = Math.abs(a.r - b.r);
      const dc = Math.abs(a.c - b.c);
      return (dr + dc === 1);
    }

    function trySwap(a, b) {
      // Swap values
      const temp = grid[a.r][a.c];
      grid[a.r][a.c] = grid[b.r][b.c];
      grid[b.r][b.c] = temp;

      const matches = findMatches();
      if (matches.length === 0) {
        // Swap back if no match
        grid[b.r][b.c] = grid[a.r][a.c];
        grid[a.r][a.c] = temp;
        renderBoard();
        return false;
      }

      // Valid move: show marked, then resolve
      renderBoard();
      markMatchesVisual(matches);
      setTimeout(() => {
        applyMatches(matches);
        // Resolve cascades
        resolveCascades();
      }, 150);

      return true;
    }

    function resolveCascades() {
      const matches = findMatches();
      if (!matches.length) {
        renderBoard();
        return;
      }
      renderBoard();
      markMatchesVisual(matches);
      setTimeout(() => {
        applyMatches(matches);
        resolveCascades();
      }, 130);
    }

    function handleTileClick(e) {
      const target = e.target.closest(".tile");
      if (!target) return;

      const r = parseInt(target.dataset.r, 10);
      const c = parseInt(target.dataset.c, 10);
      const clicked = { r, c };

      if (!selected) {
        selected = clicked;
        clearSelectionVisuals();
        target.classList.add("selected");
        return;
      }

      // If clicked same tile, deselect
      if (selected.r === clicked.r && selected.c === clicked.c) {
        selected = null;
        clearSelectionVisuals();
        return;
      }

      const prevSelected = selected;
      selected = null;
      clearSelectionVisuals();

      if (!areAdjacent(prevSelected, clicked)) {
        // Not adjacent, treat this new tile as first select
        selected = clicked;
        target.classList.add("selected");
        return;
      }

      // Adjacent: attempt swap
      trySwap(prevSelected, clicked);
    }

    // Touch support: treat taps same as clicks (no drag logic yet)
    boardEl.addEventListener("click", handleTileClick);
    boardEl.addEventListener("touchstart", function (e) {
      // Let the click handler handle logic, we just prevent fat double events
      e.preventDefault();
      const touch = e.changedTouches[0];
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      if (el && el.classList.contains("tile")) {
        el.click();
      }
    }, { passive: false });

    // ============================================================
    // üöÄ BOOTSTRAP
    // ============================================================
    function newGame() {
      score = 0;
      scoreValEl.textContent = score;
      comboValEl.textContent = 0;
      selected = null;
      generateInitialGrid();
      renderBoard();
    }

    resetBtn.addEventListener("click", newGame);

    newGame();
  </script>
</body>
</html>
