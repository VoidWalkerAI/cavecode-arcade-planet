<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Buckeye Bash ‚Äî Harvest Catch (ARC-BB-001)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!--
    ü™® BLOCK 1 ‚Äî IDENTITY [LOCKED]
    TITLE: Buckeye Bash ‚Äî Harvest Catch
    CODE: ARC-BB-001
    LINE: Buckeye Bash ‚Äî Seasonal / Theme Variants
    PURPOSE: Lane-based catch/dodge mini-game for CaveCode Arcade Planet.
    VERSION: 1.1 (CaveCode shell + 5-level track + SFX)
    AUDIENCE: Players (mobile-first) + engine readers (AI/human).

    Notes:
    - Single-file HTML engine.
    - CaveCode blocks embedded as comments.
    - Visual shell: Buckeye Bash line, unified with Mind-Chambers/Haze-Maze style.
  -->

  <style>
    :root {
      --bg: #020617;
      --panel: #0b1120;
      --border: #1f2937;
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --accent: #fb923c;

      --lane-good: #22c55e;
      --lane-bad: #ef4444;
      --lane-neutral: #eab308;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, #111827 0, #020617 60%);
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-shell {
      max-width: 900px;
      margin: 0 auto;
      padding: 0.75rem 1rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    header {
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border);
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    header .sub {
      margin-top: 0.15rem;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    #main-row {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    @media (min-width: 768px) {
      #main-row {
        flex-direction: row;
        align-items: flex-start;
      }
    }

    #playfield-panel {
      flex: 2;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, #0b1120 0, #020617 70%);
      padding: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      align-items: center;
    }

    #hud-row {
      width: 100%;
      max-width: 380px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .pill {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      padding: 0.15rem 0.6rem;
      background: rgba(15, 23, 42, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.78rem;
      white-space: nowrap;
    }

    .pill span.value {
      font-weight: 600;
      color: var(--text-main);
    }

    #start-btn {
      font-size: 0.8rem;
      padding: 0.3rem 0.8rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, rgba(251, 146, 60, 0.5), rgba(15, 23, 42, 1));
      color: var(--text-main);
      cursor: pointer;
      white-space: nowrap;
    }

    #start-btn:active {
      transform: translateY(1px);
    }

    #field-wrapper {
      width: min(360px, 100%);
      aspect-ratio: 3 / 4;
      border-radius: 0.75rem;
      border: 1px solid rgba(15, 23, 42, 1);
      background: radial-gradient(circle at top, #020617 0, #020617 70%);
      overflow: hidden;
      position: relative;
      touch-action: manipulation;
    }

    #lanes {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      pointer-events: none;
    }

    .lane {
      border-left: 1px dashed rgba(15, 23, 42, 0.8);
      border-right: 1px dashed rgba(15, 23, 42, 0.8);
    }

    .lane:first-child {
      border-left: none;
    }

    .lane:last-child {
      border-right: none;
    }

    .item {
      position: absolute;
      width: calc(100% / 3 - 8px);
      margin-left: 4px;
      margin-right: 4px;
      border-radius: 999px;
      padding: 3px 0;
      font-size: 0.7rem;
      text-align: center;
      color: #020617;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.8),
        0 4px 8px rgba(0, 0, 0, 0.6);
    }

    .item.good {
      background: #bbf7d0;
    }

    .item.bad {
      background: #fecaca;
    }

    #basket {
      position: absolute;
      bottom: 6px;
      width: calc(100% / 3 - 16px);
      height: 18px;
      border-radius: 999px;
      background: linear-gradient(to top, #92400e, #f97316);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 6px 10px rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      color: #020617;
      transition: transform 0.09s ease-out;
    }

    #status-text {
      font-size: 0.8rem;
      color: var(--text-soft);
      text-align: center;
      min-height: 1.3rem;
    }

    #info-panel {
      flex: 1;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.96);
      padding: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-soft);
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    #info-panel h2 {
      margin: 0;
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-soft);
    }

    #info-panel ul {
      margin: 0.25rem 0 0;
      padding-left: 1.1rem;
    }

    #info-panel li {
      margin-bottom: 0.18rem;
    }

    @media (max-width: 767px) {
      #info-panel {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <div id="game-shell">
    <header>
      <h1>Buckeye Bash ‚Äî Harvest Catch ¬∑ ARC-BB-001</h1>
      <div class="sub">Slide your basket between lanes. Catch the good. Dodge the junk.</div>
    </header>

    <div id="main-row">
      <section id="playfield-panel">
        <div id="hud-row">
          <div class="pill">
            Lvl: <span class="value" id="levelVal">1</span> / <span class="value">5</span>
          </div>
          <div class="pill">
            Score: <span class="value" id="scoreVal">0</span>
          </div>
          <div class="pill">
            Health: <span class="value" id="healthVal">5</span>
          </div>
          <div class="pill">
            Best Lvl: <span class="value" id="bestLevelVal">1</span>
          </div>
          <button id="start-btn">Start Harvest</button>
        </div>

        <div id="field-wrapper">
          <div id="lanes">
            <div class="lane" data-lane="0"></div>
            <div class="lane" data-lane="1"></div>
            <div class="lane" data-lane="2"></div>
          </div>
          <div id="basket">Basket</div>
        </div>

        <div id="status-text">Tap Start Harvest to begin Level 1.</div>
      </section>

      <aside id="info-panel">
        <h2>How to Play</h2>
        <p>Harvest Catch is a lane-based fall mini-game with a 5-level track:</p>
        <ul>
          <li>Tap <strong>Start Harvest</strong> to begin the current level.</li>
          <li>Move the basket with arrow keys (<strong>‚Üê ‚Üí</strong>) or by tapping left/right in the field.</li>
          <li>Catching <strong>good</strong> items adds to your score.</li>
          <li>Catching <strong>bad</strong> items reduces your health.</li>
          <li>Reach the level‚Äôs target score before your health hits zero to advance.</li>
        </ul>
        <p>Each level gets a bit faster and more crowded. Clear all five to finish the Buckeye harvest run.</p>
      </aside>
    </div>
  </div>

  <!--
    üéöÔ∏è BLOCK 2 ‚Äî TUNING KNOBS

    The LEVELS array is the main knob set. Edit values only; keep names/shape.

    LEVEL 1 ‚Äî Gentle start
      targetScore:   80
      startingHealth: 5
      fallSpeed:    130 px/sec
      spawnInterval: 900 ms
      goodItemChance: 0.75

    LEVEL 2 ‚Äî Slightly faster
      targetScore:   160
      startingHealth: 5
      fallSpeed:    155
      spawnInterval: 820
      goodItemChance: 0.72

    LEVEL 3 ‚Äî Mid-harvest
      targetScore:   260
      startingHealth: 4
      fallSpeed:    180
      spawnInterval: 760
      goodItemChance: 0.70

    LEVEL 4 ‚Äî Busy field
      targetScore:   380
      startingHealth: 4
      fallSpeed:    205
      spawnInterval: 700
      goodItemChance: 0.68

    LEVEL 5 ‚Äî Rush hour
      targetScore:   520
      startingHealth: 3
      fallSpeed:    235
      spawnInterval: 640
      goodItemChance: 0.65

    Global knobs:
      laneCount:         3
      scorePerGood:      10
      healthLossBad:      1
      difficultyScale: 0.015   (small speed factor on elapsed time)
      minSpawnInterval: 350    (clamp)
  -->

  <script>
    // üåê BLOCK 3 ‚Äî PUBLIC TEXT (labels / messages)

    const TEXT = {
      idle: (level) => `Tap Start Harvest to begin Level ${level}.`,
      running: "Catch the good harvest. Dodge the junk.",
      levelComplete: (level, last) =>
        last
          ? `Level ${level} complete! You finished the Buckeye harvest. Tap Start to replay the final run.`
          : `Level ${level} complete. Tap Start to begin the next harvest.`,
      gameOver: (level) =>
        `Harvest over on Level ${level}. Tap Start to try that level again.`,
    };

    // üîß BLOCK 4 ‚Äî BEHAVIOR (game flow & logic)
    //
    // FLOW_START:
    //  - Current level index selects LEVELS[i] from tuning knobs.
    //  - Start button:
    //      ‚Ä¢ Resets score, health, items, timers.
    //      ‚Ä¢ Places basket in middle lane.
    //      ‚Ä¢ Begins requestAnimationFrame loop.
    //  - Each frame:
    //      ‚Ä¢ Update elapsed time.
    //      ‚Ä¢ Apply difficultyScale to fallSpeed.
    //      ‚Ä¢ Spawn new items on a shrinking interval.
    //      ‚Ä¢ Move items downward; remove off-screen.
    //      ‚Ä¢ Check catch window against basket lane.
    //      ‚Ä¢ Update score/health on catches.
    //      ‚Ä¢ If score >= targetScore ‚Üí Level complete.
    //      ‚Ä¢ If health <= 0 ‚Üí Game over.
    //  - Input:
    //      ‚Ä¢ Arrow keys / A,D for left/right sliding.
    //      ‚Ä¢ Touch zones (left third / right third) for mobile.
    //
    // FLOW_END.

    // üéöÔ∏è TUNING (must stay in sync with comment block above)
    const LEVELS = [
      {
        name: "Level 1",
        targetScore: 80,
        startingHealth: 5,
        fallSpeed: 130,
        spawnIntervalMs: 900,
        goodItemChance: 0.75,
      },
      {
        name: "Level 2",
        targetScore: 160,
        startingHealth: 5,
        fallSpeed: 155,
        spawnIntervalMs: 820,
        goodItemChance: 0.72,
      },
      {
        name: "Level 3",
        targetScore: 260,
        startingHealth: 4,
        fallSpeed: 180,
        spawnIntervalMs: 760,
        goodItemChance: 0.7,
      },
      {
        name: "Level 4",
        targetScore: 380,
        startingHealth: 4,
        fallSpeed: 205,
        spawnIntervalMs: 700,
        goodItemChance: 0.68,
      },
      {
        name: "Level 5",
        targetScore: 520,
        startingHealth: 3,
        fallSpeed: 235,
        spawnIntervalMs: 640,
        goodItemChance: 0.65,
      },
    ];

    const GLOBAL_TUNING = {
      laneCount: 3,
      scorePerGood: 10,
      healthLossBad: 1,
      difficultyScale: 0.015,
      minSpawnIntervalMs: 350,
    };

    // Elements
    const fieldWrapper = document.getElementById("field-wrapper");
    const basketEl = document.getElementById("basket");
    const scoreValEl = document.getElementById("scoreVal");
    const healthValEl = document.getElementById("healthVal");
    const levelValEl = document.getElementById("levelVal");
    const bestLevelValEl = document.getElementById("bestLevelVal");
    const statusTextEl = document.getElementById("status-text");
    const startBtn = document.getElementById("start-btn");

    // State
    let laneWidthPx = 0;
    let basketLane = 1; // 0,1,2
    let items = []; // { id, lane, y, type }
    let nextItemId = 1;

    let score = 0;
    let health = 0;

    let running = false;
    let lastTime = 0;
    let spawnTimer = 0;
    let elapsedTotal = 0;

    let leftHeld = false;
    let rightHeld = false;
    let moveCooldown = 0;
    const MOVE_COOLDOWN = 0.12;

    let currentLevelIndex = 0;
    let bestLevelReached = 1;

    // SFX ‚Äî small beeps using Web Audio
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (Ctx) audioCtx = new Ctx();
      }
    }

    function playBeep(freq, duration, volume) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(
        0.001,
        audioCtx.currentTime + duration
      );
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playGoodCatch() {
      ensureAudio();
      playBeep(720, 0.08, 0.16);
    }

    function playBadCatch() {
      ensureAudio();
      playBeep(260, 0.09, 0.17);
    }

    function playLevelWin() {
      ensureAudio();
      playBeep(660, 0.08, 0.18);
      setTimeout(() => playBeep(880, 0.08, 0.18), 90);
    }

    function playGameOver() {
      ensureAudio();
      playBeep(220, 0.1, 0.17);
      setTimeout(() => playBeep(160, 0.12, 0.16), 110);
    }

    // Helpers
    function recalcLaneWidth() {
      const rect = fieldWrapper.getBoundingClientRect();
      laneWidthPx = rect.width / GLOBAL_TUNING.laneCount;
    }

    function placeBasket() {
      recalcLaneWidth();
      const offset = basketEl.offsetWidth / 2;
      const xCenter = basketLane * laneWidthPx + laneWidthPx / 2;
      const translateX = xCenter - offset - (laneWidthPx / 2 - offset);
      basketEl.style.transform = `translateX(${translateX}px)`;
    }

    function randomLane() {
      return Math.floor(Math.random() * GLOBAL_TUNING.laneCount);
    }

    function randomItemType(levelCfg) {
      return Math.random() < levelCfg.goodItemChance ? "good" : "bad";
    }

    function spawnItem(levelCfg) {
      const lane = randomLane();
      const type = randomItemType(levelCfg);
      items.push({
        id: nextItemId++,
        lane,
        y: -24,
        type,
      });
    }

    function resetRun() {
      const lvl = LEVELS[currentLevelIndex];
      score = 0;
      health = lvl.startingHealth;
      scoreValEl.textContent = String(score);
      healthValEl.textContent = String(health);
      levelValEl.textContent = String(currentLevelIndex + 1);
      bestLevelValEl.textContent = String(bestLevelReached);

      basketLane = 1;
      items = [];
      nextItemId = 1;
      spawnTimer = 0;
      elapsedTotal = 0;
      moveCooldown = 0;
      leftHeld = rightHeld = false;

      placeBasket();
      statusTextEl.textContent = TEXT.running;
    }

    function updateItemPositions(dtSec, levelCfg) {
      const rect = fieldWrapper.getBoundingClientRect();
      const height = rect.height;

      const speedFactor = 1 + elapsedTotal * GLOBAL_TUNING.difficultyScale;
      const speed = levelCfg.fallSpeed * speedFactor;

      const basketTopY = height - 36;
      const basketCatchWindow = 18;

      const remaining = [];

      for (const item of items) {
        item.y += speed * dtSec;

        if (
          item.y >= basketTopY - basketCatchWindow &&
          item.y <= basketTopY + basketCatchWindow &&
          item.lane === basketLane
        ) {
          if (item.type === "good") {
            score += GLOBAL_TUNING.scorePerGood;
            scoreValEl.textContent = String(score);
            playGoodCatch();
          } else {
            health -= GLOBAL_TUNING.healthLossBad;
            healthValEl.textContent = String(Math.max(0, health));
            playBadCatch();
          }
          continue;
        }

        if (item.y > height + 32) {
          continue;
        }

        remaining.push(item);
      }

      items = remaining;
    }

    function renderItems() {
      const old = fieldWrapper.querySelectorAll(".item");
      old.forEach((el) => el.remove());

      items.forEach((item) => {
        const el = document.createElement("div");
        el.className = "item " + item.type;
        el.dataset.id = String(item.id);
        el.style.left = item.lane * laneWidthPx + "px";
        el.style.top = item.y + "px";
        el.textContent = item.type === "good" ? "üçÇ" : "ü™®";
        fieldWrapper.appendChild(el);
      });
    }

    function moveBasketLeft() {
      if (!running) return;
      if (basketLane > 0) {
        basketLane--;
        placeBasket();
      }
    }

    function moveBasketRight() {
      if (!running) return;
      if (basketLane < GLOBAL_TUNING.laneCount - 1) {
        basketLane++;
        placeBasket();
      }
    }

    function levelComplete() {
      running = false;
      const levelNum = currentLevelIndex + 1;
      if (levelNum > bestLevelReached) {
        bestLevelReached = levelNum;
        bestLevelValEl.textContent = String(bestLevelReached);
      }
      playLevelWin();
      const isLast = currentLevelIndex === LEVELS.length - 1;
      statusTextEl.textContent = TEXT.levelComplete(levelNum, isLast);
    }

    function gameOver() {
      running = false;
      playGameOver();
      const levelNum = currentLevelIndex + 1;
      statusTextEl.textContent = TEXT.gameOver(levelNum);
    }

    // Main loop
    function loop(timestamp) {
      if (!running) return;
      if (!lastTime) lastTime = timestamp;
      const dtMs = timestamp - lastTime;
      const dtSec = dtMs / 1000;
      lastTime = timestamp;

      const levelCfg = LEVELS[currentLevelIndex];

      elapsedTotal += dtSec;
      spawnTimer += dtMs;
      moveCooldown -= dtSec;

      if (moveCooldown <= 0) {
        if (leftHeld) {
          moveBasketLeft();
          moveCooldown = MOVE_COOLDOWN;
        } else if (rightHeld) {
          moveBasketRight();
          moveCooldown = MOVE_COOLDOWN;
        }
      }

      const dynamicSpawnInterval = Math.max(
        GLOBAL_TUNING.minSpawnIntervalMs,
        levelCfg.spawnIntervalMs - elapsedTotal * 80
      );

      if (spawnTimer >= dynamicSpawnInterval) {
        spawnItem(levelCfg);
        spawnTimer = 0;
      }

      updateItemPositions(dtSec, levelCfg);
      renderItems();

      if (score >= levelCfg.targetScore) {
        levelComplete();
        return;
      }

      if (health <= 0) {
        gameOver();
        return;
      }

      requestAnimationFrame(loop);
    }

    // Events
    window.addEventListener("resize", () => {
      placeBasket();
      renderItems();
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") leftHeld = true;
      if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") rightHeld = true;
    });

    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") leftHeld = false;
      if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") rightHeld = false;
    });

    fieldWrapper.addEventListener(
      "touchstart",
      (e) => {
        const rect = fieldWrapper.getBoundingClientRect();
        const x = e.changedTouches[0].clientX - rect.left;
        const third = rect.width / 3;
        if (x < third) {
          leftHeld = true;
          rightHeld = false;
          moveBasketLeft();
        } else if (x > 2 * third) {
          rightHeld = true;
          leftHeld = false;
          moveBasketRight();
        } else {
          leftHeld = rightHeld = false;
        }
      },
      { passive: true }
    );

    fieldWrapper.addEventListener(
      "touchend",
      () => {
        leftHeld = rightHeld = false;
      },
      { passive: true }
    );

    startBtn.addEventListener("click", () => {
      ensureAudio();
      running = true;
      lastTime = 0;
      resetRun();
      requestAnimationFrame(loop);
    });

    // Initial layout
    setTimeout(() => {
      placeBasket();
      statusTextEl.textContent = TEXT.idle(currentLevelIndex + 1);
    }, 0);

    // üìù BLOCK 5 ‚Äî HUMAN NOTES
    //
    // [IDEAS]
    // - Add seasonal skins (icons + lane tint) via a simple theme knob.
    // - Add a ‚Äúperfect harvest‚Äù bonus if no bad items are caught on a level.
    // - Add an endless mode that unlocks after clearing Level 5.
  </script>
</body>
</html>
