<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mind Chambers â€” Focus Relay (ARC-MC-002)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --panel-soft: #0b1120;
      --border: #1f2937;
      --border-soft: #111827;
      --accent: #38bdf8;
      --accent-soft: #22c55e;
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --chip-bg: #020617;
      --chip-pill: #111827;

      --node-idle: #020617;
      --node-hover: #111827;
      --node-reveal: #38bdf8;
      --node-correct: #22c55e;
      --node-wrong: #ef4444;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #111827 0, #020617 60%);
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
    }

    #game-shell {
      max-width: 1024px;
      width: 100%;
      margin: 0 auto;
      padding: 1rem 0.75rem 2.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    /* HEADER STRIP */

    header {
      border-radius: 1.25rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, #020617 0, #020617 45%, #020617 100%);
      padding: 0.9rem 1.1rem 0.85rem;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.65);
    }

    header-top {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
      width: 100%;
    }

    header-top h1 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    header-top .tagline {
      font-size: 0.78rem;
      color: var(--text-soft);
      text-align: right;
      white-space: nowrap;
    }

    header-sub {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      align-items: center;
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .badge {
      padding: 0.05rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.16);
      text-transform: uppercase;
      letter-spacing: 0.11em;
      font-size: 0.7rem;
      background: rgba(15, 23, 42, 0.95);
      color: var(--accent);
    }

    .chip-row {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .chip {
      padding: 0.12rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #1f2937;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      background: var(--chip-pill);
      color: var(--text-soft);
      white-space: nowrap;
    }

    /* MAIN LAYOUT */

    #frame {
      border-radius: 1.25rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, #020617 0, #020617 55%, #020617 100%);
      padding: 1rem 1.05rem 1.15rem;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      box-shadow: 0 22px 55px rgba(0, 0, 0, 0.85);
    }

    @media (min-width: 860px) {
      #frame {
        flex-direction: row;
        align-items: flex-start;
      }
    }

    /* LEFT: HUD + BOARD */

    #left-column {
      flex: 2;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .hud-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.45rem;
      font-size: 0.78rem;
    }

    .hud-cell {
      border-radius: 0.8rem;
      border: 1px solid var(--border-soft);
      background: linear-gradient(135deg, #020617, #020617);
      padding: 0.35rem 0.55rem 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .hud-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.65rem;
      color: var(--text-soft);
    }

    .hud-value {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .hud-note {
      font-size: 0.65rem;
      color: var(--text-soft);
    }

    #play-wrapper {
      margin-top: 0.2rem;
      border-radius: 1.1rem;
      border: 1px solid var(--border-soft);
      background: radial-gradient(circle at top, #020617 0, #020617 60%);
      padding: 0.8rem 0.75rem 0.9rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.6rem;
      width: 100%;
      max-width: 280px;
    }

    .node {
      position: relative;
      width: 100%;
      padding-top: 100%;
      border-radius: 999px;
      background: var(--node-idle);
      border: 1px solid var(--border-soft);
      cursor: pointer;
      transition: background 0.12s ease-out, transform 0.08s ease-out;
    }

    .node-inner {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: 600;
    }

    .node:hover {
      background: var(--node-hover);
    }

    .node.reveal {
      background: var(--node-reveal);
    }

    .node.correct {
      background: var(--node-correct);
    }

    .node.wrong {
      background: var(--node-wrong);
    }

    #controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 280px;
      font-size: 0.8rem;
      color: var(--text-soft);
      gap: 0.6rem;
    }

    #status {
      flex: 1;
      min-height: 1.2rem;
    }

    #startBtn {
      padding: 0.3rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.85);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.6), rgba(15, 23, 42, 1));
      color: var(--text-main);
      font-size: 0.8rem;
      cursor: pointer;
      white-space: nowrap;
    }

    #startBtn:active {
      transform: translateY(1px);
    }

    /* RIGHT: RULES PANEL */

    #right-column {
      flex: 1.1;
      border-radius: 1.1rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, #020617 0, #020617 60%);
      padding: 0.8rem 0.85rem 0.9rem;
      font-size: 0.8rem;
      color: var(--text-soft);
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    #right-column h2 {
      margin: 0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
    }

    #right-column p {
      margin: 0.1rem 0 0.25rem;
    }

    #right-column ul {
      margin: 0.25rem 0 0.25rem 1.05rem;
      padding: 0;
    }

    #right-column li {
      margin-bottom: 0.18rem;
    }

    footer {
      margin-top: 0.75rem;
      font-size: 0.72rem;
      color: var(--text-soft);
      text-align: center;
      opacity: 0.85;
    }

    @media (max-width: 720px) {
      header-top {
        flex-direction: column;
        align-items: flex-start;
      }

      header-top .tagline = {
        text-align: left;
      }

      .hud-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      #frame {
        padding: 0.85rem 0.8rem 0.95rem;
      }

      #right-column {
        order: 2;
      }
    }

    @media (max-width: 480px) {
      #game-shell {
        padding-inline: 0.5rem;
      }

      #frame {
        padding-inline: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div id="game-shell">
    <header>
      <header-top>
        <h1>Mind Chambers â€” Focus Relay Â· ARC-MC-002</h1>
        <div class="tagline">Visual sequence memory Â· CaveCode Arcade Planet Â· Single-file HTML engine</div>
      </header-top>
      <header-sub>
        <span class="badge">Level Track</span>
        <span class="badge">Sequence Grid</span>
        <span class="badge">Reveal Window</span>
      </header-sub>
      <div class="chip-row">
        <span class="chip">Mind Chambers Line</span>
        <span class="chip">Memory / Focus</span>
        <span class="chip">Mobile-first</span>
      </div>
    </header>

    <main id="frame">
      <!-- LEFT: HUD + BOARD -->
      <section id="left-column">
        <div class="hud-grid">
          <div class="hud-cell">
            <div class="hud-label">Round</div>
            <div class="hud-value" id="hudRound">0</div>
            <div class="hud-note">Completed this run</div>
          </div>
          <div class="hud-cell">
            <div class="hud-label">Best Run</div>
            <div class="hud-value" id="hudBest">0</div>
            <div class="hud-note">Longest streak</div>
          </div>
          <div class="hud-cell">
            <div class="hud-label">Pattern Length</div>
            <div class="hud-value" id="hudPattern">3</div>
            <div class="hud-note">Nodes to remember</div>
          </div>
          <div class="hud-cell">
            <div class="hud-label">Reveal Time</div>
            <div class="hud-value" id="hudReveal">1.6s</div>
            <div class="hud-note">Current window</div>
          </div>
          <div class="hud-cell">
            <div class="hud-label">Tier</div>
            <div class="hud-value" id="hudTier">1</div>
            <div class="hud-note">1â€“5 difficulty band</div>
          </div>
          <div class="hud-cell">
            <div class="hud-label">Run State</div>
            <div class="hud-value" id="hudState">Idle</div>
            <div class="hud-note">Tap Start Round</div>
          </div>
        </div>

        <div id="play-wrapper">
          <div id="grid"></div>
          <div id="controls-row">
            <div id="status">Tap Start Round to begin.</div>
            <button id="startBtn">Start Round</button>
          </div>
        </div>
      </section>

      <!-- RIGHT: RULES / COPY -->
      <aside id="right-column">
        <h2>How to Play</h2>
        <p>
          Focus Relay is a visual working-memory test. A pattern of nodes lights up with numbers
          for a brief moment. When the numbers fade, you must tap the nodes back in the correct order
          from memory.
        </p>
        <ul>
          <li>Tap <strong>Start Round</strong> to generate a new pattern.</li>
          <li>Numbers <em>1..N</em> appear on random nodes. Memorize them quickly.</li>
          <li>When they vanish, tap the nodes in ascending order.</li>
          <li>Each successful round makes the pattern longer and the reveal window tighter.</li>
        </ul>

        <h2>Fail &amp; Feedback</h2>
        <p>
          If you tap the wrong node, the run ends. Your mistake is marked in red, and the
          <strong>full correct path</strong> reappears in blue so you can see the sequence you missed.
        </p>
        <ul>
          <li><strong>Rounds</strong> â€” how many patterns youâ€™ve cleared this run.</li>
          <li><strong>Best Run</strong> â€” your longest streak so far.</li>
          <li><strong>Pattern Length</strong> â€” how many nodes are currently in the sequence.</li>
          <li><strong>Reveal Time</strong> â€” how long the numbers stay visible at the start.</li>
          <li><strong>Tier</strong> â€” 1 (easiest) through 5 (hardest) based on pattern length.</li>
        </ul>
        <p>
          Tap <strong>Start Round</strong> to reset and push for a deeper run.
        </p>
      </aside>
    </main>

    <footer>
      Forged in CaveCode Arcade Planet Â· SageWire Syndicate Â· Mind Chambers Â· ARC-MC-002
    </footer>
  </div>

  <script>
    // ============================================================
    // ðŸŽšï¸ TUNING (sync with focus-relay.cavecode)
    // ============================================================
    const TUNING = {
      gridSize: 3,
      startPatternLength: 3,
      patternIncrement: 1,
      revealTimeMs: 1600,
      minRevealTimeMs: 700,
      revealTimeDecayMs: 100
    };

    // ============================================================
    // ELEMENTS
    // ============================================================
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const startBtn = document.getElementById("startBtn");

    const hudRound = document.getElementById("hudRound");
    const hudBest = document.getElementById("hudBest");
    const hudPattern = document.getElementById("hudPattern");
    const hudReveal = document.getElementById("hudReveal");
    const hudTier = document.getElementById("hudTier");
    const hudState = document.getElementById("hudState");

    // ============================================================
    // STATE
    // ============================================================
    const STATE = {
      IDLE: "Idle",
      REVEAL: "Reveal",
      INPUT: "Input",
      GAME_OVER: "Game Over"
    };

    let currentState = STATE.IDLE;

    let nodes = []; // {el, inner}
    let pattern = []; // array of node indices
    let expectedIndex = 1;
    let patternLength = TUNING.startPatternLength;
    let revealTimeMs = TUNING.revealTimeMs;

    let roundsCompleted = 0;
    let bestRounds = 0;
    let revealTimeoutId = null;

    // Audio
    let audioCtx = null;

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playTone(freq, durationMs = 160, type = "sine", gain = 0.18) {
      if (!audioCtx) return;
      const ctx = audioCtx;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g);
      g.connect(ctx.destination);
      const now = ctx.currentTime;
      osc.start(now);
      osc.stop(now + durationMs / 1000);
      g.gain.exponentialRampToValueAtTime(0.001, now + durationMs / 1000);
    }

    function playRevealChime() {
      playTone(660, 140, "sine", 0.2);
    }

    function playCorrectBlip() {
      playTone(880, 120, "triangle", 0.2);
    }

    function playFailSting() {
      playTone(240, 260, "sawtooth", 0.23);
      setTimeout(() => playTone(160, 220, "sawtooth", 0.2), 120);
    }

    // ============================================================
    // HELPERS
    // ============================================================
    function patternToTier(len) {
      if (len <= 4) return 1;
      if (len <= 6) return 2;
      if (len <= 8) return 3;
      if (len <= 10) return 4;
      return 5;
    }

    function updateTier() {
      hudTier.textContent = String(patternToTier(patternLength));
    }

    function setState(newState) {
      currentState = newState;
      hudState.textContent = newState;
    }

    function clearNodeStyles(full = true) {
      nodes.forEach(n => {
        if (full || !n.el.classList.contains("wrong")) {
          n.el.classList.remove("reveal", "correct");
          if (full) {
            n.el.classList.remove("wrong");
          }
          n.inner.textContent = "";
        }
      });
    }

    function showCorrectPattern() {
      clearNodeStyles(false);
      pattern.forEach((nodeIndex, i) => {
        const n = nodes[nodeIndex];
        if (!n.el.classList.contains("wrong")) {
          n.el.classList.add("reveal");
          n.inner.textContent = String(i + 1);
        }
      });
    }

    // ============================================================
    // GRID + PATTERN
    // ============================================================
    function buildGrid() {
      gridEl.innerHTML = "";
      nodes = [];
      const total = TUNING.gridSize * TUNING.gridSize;

      for (let i = 0; i < total; i++) {
        const node = document.createElement("button");
        node.className = "node";
        node.type = "button";
        node.dataset.index = String(i);

        const inner = document.createElement("div");
        inner.className = "node-inner";
        inner.textContent = "";
        node.appendChild(inner);

        node.addEventListener("click", () => onNodeClick(i));

        gridEl.appendChild(node);
        nodes.push({ el: node, inner });
      }

      gridEl.style.gridTemplateColumns = `repeat(${TUNING.gridSize}, 1fr)`;
    }

    function generatePattern() {
      pattern = [];
      const indices = Array.from({ length: nodes.length }, (_, i) => i);

      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      pattern = indices.slice(0, patternLength);
    }

    // ============================================================
    // ROUND FLOW
    // ============================================================
    function startRun() {
      roundsCompleted = 0;
      hudRound.textContent = "0";

      patternLength = TUNING.startPatternLength;
      revealTimeMs = TUNING.revealTimeMs;

      hudPattern.textContent = String(patternLength);
      hudReveal.textContent = (revealTimeMs / 1000).toFixed(1) + "s";
      updateTier();

      startRound();
    }

    function startRound() {
      if (revealTimeoutId) {
        clearTimeout(revealTimeoutId);
        revealTimeoutId = null;
      }
      clearNodeStyles(true);
      expectedIndex = 1;
      generatePattern();
      hudPattern.textContent = String(patternLength);
      updateTier();
      revealPattern();
    }

    function revealPattern() {
      setState(STATE.REVEAL);
      statusEl.textContent = "Memorize the numbers...";
      playRevealChime();

      pattern.forEach((nodeIndex, i) => {
        const n = nodes[nodeIndex];
        n.el.classList.add("reveal");
        n.inner.textContent = String(i + 1);
      });

      revealTimeoutId = setTimeout(() => {
        clearNodeStyles(true);
        setState(STATE.INPUT);
        statusEl.textContent = "Tap the nodes in order.";
      }, revealTimeMs);

      hudReveal.textContent = (revealTimeMs / 1000).toFixed(1) + "s";
    }

    function handleCorrectClick(nodeIndex) {
      const n = nodes[nodeIndex];
      n.el.classList.add("correct");
      playCorrectBlip();

      expectedIndex++;
      if (expectedIndex > patternLength) {
        roundsCompleted++;
        hudRound.textContent = String(roundsCompleted);
        if (roundsCompleted > bestRounds) {
          bestRounds = roundsCompleted;
          hudBest.textContent = String(bestRounds);
        }

        setState(STATE.IDLE);
        statusEl.textContent = "Nice. New pattern loadingâ€¦";

        patternLength += TUNING.patternIncrement;
        revealTimeMs = Math.max(
          TUNING.minRevealTimeMs,
          revealTimeMs - TUNING.revealTimeDecayMs
        );

        setTimeout(() => {
          if (currentState !== STATE.GAME_OVER) {
            startRound();
          }
        }, 700);
      }
    }

    function handleWrongClick(nodeIndex) {
      const n = nodes[nodeIndex];
      n.el.classList.add("wrong");
      playFailSting();
      setState(STATE.GAME_OVER);
      statusEl.textContent = "Sequence broken. Tap Start Round to try again.";

      showCorrectPattern();
    }

    // ============================================================
    // INPUT
    // ============================================================
    function onNodeClick(nodeIndex) {
      if (currentState !== STATE.INPUT) return;

      const expectedNodeIndex = pattern[expectedIndex - 1];
      if (nodeIndex === expectedNodeIndex) {
        handleCorrectClick(nodeIndex);
      } else {
        handleWrongClick(nodeIndex);
      }
    }

    // ============================================================
    // BUTTON
    // ============================================================
    startBtn.addEventListener("click", () => {
      ensureAudio();
      setState(STATE.IDLE);
      statusEl.textContent = "Memorize the numbers...";
      startRun();
    });

    // ============================================================
    // INIT
    // ============================================================
    buildGrid();
    setState(STATE.IDLE);
    hudBest.textContent = "0";
    hudRound.textContent = "0";
    hudPattern.textContent = String(TUNING.startPatternLength);
    hudReveal.textContent = (TUNING.revealTimeMs / 1000).toFixed(1) + "s";
    updateTier();
  </script>
</body>
</html>
