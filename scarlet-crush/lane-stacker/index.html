<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scarlet Crush — Lane Stacker · ARC-SC-001</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!--
    BLOCK 1 — SHELL & BRAND (LOCKED)
    CaveCode Arcade Planet · Scarlet-Crush Line
  -->
  <style>
    :root {
      --cc-bg: #020617;
      --cc-panel: #02081b;
      --cc-panel-soft: #0b1120;
      --cc-border: #1f2937;
      --cc-accent: #fb7185;
      --cc-accent-soft: #fed7e2;
      --cc-text-main: #e5e7eb;
      --cc-text-soft: #9ca3af;

      --tile-radius: 0.45rem;
      --tile-gap: 0.24rem;
      --tile-size: min(6vw, 2.4rem);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      background:
        radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--cc-text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 1.25rem 0.75rem 2.5rem;
    }

    .shell {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    header {
      background: linear-gradient(135deg, #020617, #0b1120);
      border-radius: 999px;
      border: 1px solid var(--cc-border);
      padding: 0.9rem 1.5rem;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.65);
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    @media (min-width: 640px) {
      header {
        flex-direction: row;
        justify-content: space-between;
        align-items: baseline;
      }
    }

    .title-line {
      font-size: clamp(1rem, 2.2vw, 1.15rem);
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .title-line span.code {
      color: var(--cc-accent);
    }

    .sub-line {
      font-size: 0.8rem;
      color: var(--cc-text-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .pill {
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .pill.hot {
      border-color: rgba(248, 113, 113, 0.6);
      background: radial-gradient(circle at top left, #111827, #020617);
    }

    main {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .panel {
      background: radial-gradient(circle at top, #020617 0, #020617 20%, #020617 100%);
      border-radius: 1.25rem;
      border: 1px solid var(--cc-border);
      padding: 1rem 1rem 1.15rem;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .panel-title {
      font-size: 0.78rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--cc-text-soft);
    }

    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .tag {
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .tag.chip {
      background: #020617;
    }

    .tag.accent {
      border-color: rgba(248, 113, 113, 0.7);
      color: var(--cc-accent-soft);
    }

    .hint {
      font-size: 0.83rem;
      color: var(--cc-text-soft);
    }

    /* HUD */

    .hud-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.6rem;
    }

    .hud-card {
      border-radius: 0.9rem;
      border: 1px solid rgba(30, 64, 175, 0.7);
      background: radial-gradient(circle at top, #020617, #020617);
      padding: 0.5rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
      min-height: 3.1rem;
    }

    .hud-label {
      font-size: 0.68rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--cc-text-soft);
    }

    .hud-value {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .hud-value.accent {
      color: var(--cc-accent-soft);
    }

    /* Playfield */

    .playfield-wrapper {
      margin-top: 0.35rem;
      border-radius: 1.25rem;
      border: 1px solid rgba(15, 23, 42, 0.9);
      background:
        radial-gradient(circle at top left, #020617, #020617 45%, #020617 100%);
      padding: 0.75rem 0.85rem 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
    }

    .board-frame {
      border-radius: 1.1rem;
      border: 1px solid rgba(30, 64, 175, 0.7);
      background: radial-gradient(circle at top, #020617, #020617 55%, #020617);
      padding: 0.65rem;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .board {
      width: 100%;
      max-width: 420px;
      aspect-ratio: 7 / 12;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(12, 1fr);
      gap: var(--tile-gap);
    }

    .cell {
      border-radius: var(--tile-radius);
      background: radial-gradient(circle at top, #020617, #020617 60%, #020617);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tile {
      width: 100%;
      height: 100%;
      border-radius: var(--tile-radius);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9),
                  0 6px 14px rgba(0, 0, 0, 0.8);
      transition: transform 0.18s ease-out, box-shadow 0.18s ease-out;
    }

    .tile.spawn {
      animation: drop-in 0.2s ease-out forwards;
    }

    .tile.clearing {
      animation: flash-out 0.24s ease-in-out 0s 3 alternate;
    }

    @keyframes drop-in {
      0% {
        transform: translateY(-22px);
        box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9),
                    0 2px 8px rgba(0, 0, 0, 0.7);
      }
      100% {
        transform: translateY(0);
        box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9),
                    0 6px 14px rgba(0, 0, 0, 0.9);
      }
    }

    @keyframes flash-out {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.6),
                    0 6px 16px rgba(248, 113, 113, 0.3);
      }
      100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9),
                    0 2px 8px rgba(0, 0, 0, 0.6);
      }
    }

    .tile.c0 { background: linear-gradient(145deg, #f97373, #b91c1c); }
    .tile.c1 { background: linear-gradient(145deg, #38bdf8, #1d4ed8); }
    .tile.c2 { background: linear-gradient(145deg, #4ade80, #15803d); }
    .tile.c3 { background: linear-gradient(145deg, #facc15, #b45309); }
    .tile.c4 { background: linear-gradient(145deg, #a855f7, #6d28d9); }

    .tile.special-row {
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.8),
                  0 6px 18px rgba(56, 189, 248, 0.5);
    }

    .tile.special-bomb {
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.85),
                  0 6px 18px rgba(248, 113, 113, 0.55);
    }

    /* Lane controls */

    .lane-row {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .lane-label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      color: var(--cc-text-soft);
    }

    .lane-buttons {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.35rem;
    }

    .lane-btn {
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: radial-gradient(circle at top, #020617, #020617 65%, #020617);
      color: var(--cc-text-main);
      font-size: 0.78rem;
      padding: 0.35rem 0.15rem;
      border-radius: 999px;
      cursor: pointer;
      text-align: center;
      user-select: none;
      transition: background 0.15s ease-out, transform 0.1s ease-out,
        box-shadow 0.15s ease-out;
    }

    .lane-btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }

    .lane-btn.disabled {
      opacity: 0.35;
      cursor: default;
    }

    .lane-btn.hot {
      border-color: rgba(248, 113, 113, 0.7);
      color: var(--cc-accent-soft);
    }

    /* Footer / actions */

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: space-between;
      margin-top: 0.3rem;
    }

    .btn {
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      font-size: 0.82rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at top, #020617, #020617 60%);
      color: var(--cc-text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      user-select: none;
    }

    .btn.primary {
      border-color: rgba(248, 113, 113, 0.85);
      background: radial-gradient(circle at top, #7f1d1d, #b91c1c);
      color: #fef2f2;
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }

    .footer-note {
      font-size: 0.78rem;
      color: var(--cc-text-soft);
    }

    .status-text {
      font-size: 0.78rem;
      color: var(--cc-text-soft);
      min-height: 1.1rem;
    }

    .brand-line {
      font-size: 0.76rem;
      color: var(--cc-text-soft);
      text-align: center;
      margin-top: 0.4rem;
    }

    /* Modal */

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    .modal-backdrop.hidden {
      display: none;
    }

    .modal {
      width: 100%;
      max-width: 360px;
      border-radius: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at top, #020617, #020617 65%);
      padding: 1.25rem 1.35rem 1.1rem;
      box-shadow: 0 24px 50px rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .modal h2 {
      font-size: 1.05rem;
      margin: 0;
    }

    .modal p {
      font-size: 0.86rem;
      margin: 0;
      color: var(--cc-text-soft);
    }

    .modal-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.35rem;
    }

    .modal-actions .btn {
      flex: 1;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title-line">
        SCARLET CRUSH — <span class="code">LANE STACKER · ARC-SC-001</span>
      </div>
      <div class="sub-line">
        <span>CaveCode Arcade Planet</span>
        <span>•</span>
        <span>Falling Blocks · Lane Puzzle</span>
        <span>•</span>
        <span>Single-file HTML Engine</span>
      </div>
    </header>

    <main>
      <section class="panel">
        <div class="panel-title">Track Overview</div>
        <div class="tag-row">
          <span class="tag accent">Level Track</span>
          <span class="tag chip">Lane Stacking</span>
          <span class="tag chip">Row Clears</span>
          <span class="tag chip">Score Multipliers</span>
          <span class="tag chip">Special Gems</span>
          <span class="tag chip">Sound &amp; Pop</span>
        </div>
        <p class="hint">
          Tap a lane to drop the next block. Make solid-color rows before the stack reaches the top.
          Build chains for bonus multipliers.
        </p>

        <div class="hud-grid">
          <div class="hud-card">
            <div class="hud-label">Level</div>
            <div class="hud-value" id="hud-level">1</div>
          </div>
          <div class="hud-card">
            <div class="hud-label">Score</div>
            <div class="hud-value accent" id="hud-score">0</div>
          </div>
          <div class="hud-card">
            <div class="hud-label">Target</div>
            <div class="hud-value" id="hud-target">0</div>
          </div>
          <div class="hud-card">
            <div class="hud-label">Drops Left</div>
            <div class="hud-value" id="hud-drops">0</div>
          </div>
          <div class="hud-card">
            <div class="hud-label">Rows Cleared</div>
            <div class="hud-value" id="hud-rows">0</div>
          </div>
          <div class="hud-card">
            <div class="hud-label">Best Chain</div>
            <div class="hud-value" id="hud-chain">x1.0</div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-title">Playfield</div>
        <div class="playfield-wrapper">
          <div class="board-frame">
            <div class="board" id="board"></div>
          </div>

          <div class="lane-row">
            <div class="lane-label-row">
              <span>Next Block: <span id="nextColorLabel">●</span></span>
              <span>Tap a lane button to drop.</span>
            </div>
            <div class="lane-buttons">
              <button class="lane-btn hot" data-lane="0">1</button>
              <button class="lane-btn" data-lane="1">2</button>
              <button class="lane-btn" data-lane="2">3</button>
              <button class="lane-btn" data-lane="3">4</button>
              <button class="lane-btn" data-lane="4">5</button>
              <button class="lane-btn" data-lane="5">6</button>
              <button class="lane-btn" data-lane="6">7</button>
            </div>
          </div>
        </div>

        <div class="status-text" id="statusText"></div>
      </section>

      <section class="panel">
        <div class="panel-title">Controls &amp; Rules</div>
        <p class="hint">
          Match full rows of a single color to clear them. Clearing multiple rows in one cascade
          builds a chain multiplier. Special gems appear on big chains:
          <strong>Row</strong> clears a whole row; <strong>Bomb</strong> blasts a 3×3 chunk.
        </p>
        <div class="actions-row">
          <div class="actions-left">
            <button class="btn" id="btn-restart">
              ↻ Restart Level
            </button>
          </div>
          <div class="actions-right">
            <button class="btn primary" id="btn-next">
              ➜ Next Level
            </button>
          </div>
        </div>
        <div class="brand-line">
          Forged in CaveCode Arcade Planet · SageWire Syndicate
        </div>
      </section>
    </main>
  </div>

  <!-- Modal -->
  <div class="modal-backdrop hidden" id="modal">
    <div class="modal">
      <h2 id="modal-title">Level Complete</h2>
      <p id="modal-body">
        You reached the target. Ready for the next stack?
      </p>
      <div class="modal-actions">
        <button class="btn" id="modal-restart">↻ Replay Level</button>
        <button class="btn primary" id="modal-next">➜ Continue</button>
      </div>
    </div>
  </div>

  <!--
    BLOCK 5 — GAME SCRIPT (EDITABLE)
    Lane Stacker Engine · Animated Drops
  -->
  <script>
    // --- Config -------------------------------------------------------------

    const ROWS = 12;
    const COLS = 7;

    const COLORS = [
      { id: 0, label: "Red", className: "c0" },
      { id: 1, label: "Blue", className: "c1" },
      { id: 2, label: "Green", className: "c2" },
      { id: 3, label: "Gold", className: "c3" },
      { id: 4, label: "Violet", className: "c4" }
    ];

    // Difficulty tuned to feel like "Beginner Tetris → Arcade Tetris"
    const LEVELS = [
      {
        name: "Level 1 — Warm-Up Stack",
        targetScore: 900,
        maxDrops: 30,
        colorCount: 3
      },
      {
        name: "Level 2 — Color Ramp",
        targetScore: 2200,
        maxDrops: 28,
        colorCount: 4
      },
      {
        name: "Level 3 — Chain Builder",
        targetScore: 3800,
        maxDrops: 26,
        colorCount: 4
      },
      {
        name: "Level 4 — Scarlet Crest",
        targetScore: 5200,
        maxDrops: 24,
        colorCount: 5
      }
    ];

    const SCORE_PER_ROW = 200;
    const SCORE_CHAIN_BONUS = 0.35; // each extra row in a cascade

    // --- State --------------------------------------------------------------

    let board = [];
    let currentLevelIndex = 0;
    let score = 0;
    let dropsLeft = 0;
    let rowsClearedTotal = 0;
    let bestChain = 1;
    let currentChain = 1;
    let nextColorId = 0;
    let isResolving = false;
    let isGameOver = false;

    // track which tile just spawned for animation
    let lastSpawn = null;

    // --- Elements -----------------------------------------------------------

    const boardEl = document.getElementById("board");
    const statusTextEl = document.getElementById("statusText");
    const nextColorLabelEl = document.getElementById("nextColorLabel");

    const hudLevel = document.getElementById("hud-level");
    const hudScore = document.getElementById("hud-score");
    const hudTarget = document.getElementById("hud-target");
    const hudDrops = document.getElementById("hud-drops");
    const hudRows = document.getElementById("hud-rows");
    const hudChain = document.getElementById("hud-chain");

    const btnRestart = document.getElementById("btn-restart");
    const btnNext = document.getElementById("btn-next");
    const laneButtons = Array.from(document.querySelectorAll(".lane-btn"));

    const modalBackdrop = document.getElementById("modal");
    const modalTitle = document.getElementById("modal-title");
    const modalBody = document.getElementById("modal-body");
    const modalRestart = document.getElementById("modal-restart");
    const modalNext = document.getElementById("modal-next");

    // --- Simple Web Audio beeps --------------------------------------------

    let audioCtx = null;

    function getAudioCtx() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) audioCtx = new AudioContext();
      }
      return audioCtx;
    }

    function playBeep(freq, duration, gain = 0.12) {
      const ctx = getAudioCtx();
      if (!ctx) return;

      const osc = ctx.createOscillator();
      const vol = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      vol.gain.value = gain;
      osc.connect(vol);
      vol.connect(ctx.destination);
      const now = ctx.currentTime;
      osc.start(now);
      osc.stop(now + duration);
    }

    function playDropSound() {
      playBeep(220, 0.05);
    }

    function playRowClearSound() {
      playBeep(520, 0.08, 0.14);
    }

    function playLevelUpSound() {
      playBeep(660, 0.12, 0.16);
      setTimeout(() => playBeep(880, 0.1, 0.16), 90);
    }

    function playFailSound() {
      playBeep(120, 0.12, 0.16);
    }

    // --- Helpers ------------------------------------------------------------

    function makeEmptyBoard() {
      board = Array.from({ length: ROWS }, () =>
        Array.from({ length: COLS }, () => null)
      );
    }

    function setStatus(text) {
      statusTextEl.textContent = text;
    }

    function updateHud() {
      const level = LEVELS[currentLevelIndex];
      hudLevel.textContent = currentLevelIndex + 1;
      hudScore.textContent = score.toString();
      hudTarget.textContent = level.targetScore.toString();
      hudDrops.textContent = dropsLeft.toString();
      hudRows.textContent = rowsClearedTotal.toString();
      hudChain.textContent = "x" + currentChain.toFixed(1);
    }

    function chooseNextColor() {
      const level = LEVELS[currentLevelIndex];
      const available = COLORS.slice(0, level.colorCount);
      const choice = available[Math.floor(Math.random() * available.length)];
      nextColorId = choice.id;

      nextColorLabelEl.textContent = "●";
      nextColorLabelEl.style.color = getColorCSS(choice.id);
    }

    function getColorCSS(id) {
      switch (id) {
        case 0: return "#f97373";
        case 1: return "#38bdf8";
        case 2: return "#4ade80";
        case 3: return "#facc15";
        case 4: return "#a855f7";
        default: return "#e5e7eb";
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cellEl = document.createElement("div");
          cellEl.className = "cell";
          cellEl.dataset.row = r;
          cellEl.dataset.col = c;

          const tile = board[r][c];
          if (tile) {
            const tileEl = document.createElement("div");
            tileEl.className = "tile " + COLORS[tile.color].className;
            if (tile.special === "row") tileEl.classList.add("special-row");
            if (tile.special === "bomb") tileEl.classList.add("special-bomb");

            if (lastSpawn && lastSpawn.row === r && lastSpawn.col === c) {
              tileEl.classList.add("spawn");
            }

            cellEl.appendChild(tileEl);
          }

          boardEl.appendChild(cellEl);
        }
      }
    }

    function highlightRows(rows) {
      rows.forEach((rowIndex) => {
        for (let c = 0; c < COLS; c++) {
          const selector = `.cell[data-row="${rowIndex}"][data-col="${c}"] .tile`;
          const tileEl = boardEl.querySelector(selector);
          if (tileEl) {
            tileEl.classList.add("clearing");
          }
        }
      });
    }

    function findFullRows() {
      const rows = [];
      for (let r = 0; r < ROWS; r++) {
        let firstColor = null;
        let solid = true;
        for (let c = 0; c < COLS; c++) {
          const tile = board[r][c];
          if (!tile) {
            solid = false;
            break;
          }
          if (firstColor === null) {
            firstColor = tile.color;
          } else if (tile.color !== firstColor) {
            solid = false;
            break;
          }
        }
        if (solid && firstColor !== null) {
          rows.push(r);
        }
      }
      return rows;
    }

    function removeRows(rows) {
      rows.sort((a, b) => a - b);
      for (let i = 0; i < rows.length; i++) {
        const rowIndex = rows[i] - i; // board height shrinks as we splice
        board.splice(rowIndex, 1);
        board.unshift(Array.from({ length: COLS }, () => null));
      }
    }

    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function maybeSpawnSpecial(rowCountInCascade, clearedRowIndex) {
      // Simple rule: big cascades have a chance to leave a special in the new top row
      if (rowCountInCascade < 2) return;
      const chance = Math.min(0.4, 0.15 + rowCountInCascade * 0.1);
      if (Math.random() > chance) return;

      const specialType = Math.random() < 0.6 ? "row" : "bomb";
      const col = Math.floor(Math.random() * COLS);
      const row = clearedRowIndex;

      if (!board[row][col]) return;
      board[row][col].special = specialType;
    }

    async function resolveBoard() {
      isResolving = true;
      let cascade = 0;
      let clearedAny = false;

      while (true) {
        const fullRows = findFullRows();
        if (!fullRows.length) {
          if (!clearedAny) {
            currentChain = 1.0;
            updateHud();
          }
          break;
        }

        clearedAny = true;
        cascade += 1;
        playRowClearSound();
        highlightRows(fullRows);

        await delay(260);

        const rowsThisCascade = fullRows.length;
        rowsClearedTotal += rowsThisCascade;

        // chain bonus: more rows in the same cascade → higher multiplier
        const chainBoost = 1 + (rowsThisCascade - 1) * SCORE_CHAIN_BONUS;
        currentChain = parseFloat(
          (currentChain + 0.3 * chainBoost).toFixed(1)
        );
        if (currentChain < 1.0) currentChain = 1.0;
        bestChain = Math.max(bestChain, currentChain);

        const addedScore =
          rowsThisCascade * SCORE_PER_ROW * currentChain;
        score += Math.round(addedScore);

        // tiny chance to leave a special behind in the "shockwave"
        maybeSpawnSpecial(rowsThisCascade, fullRows[0]);

        removeRows(fullRows);
        renderBoard();
        updateHud();

        await delay(80);
      }

      isResolving = false;
      checkLevelEnd();
    }

    function dropBlockInLane(colIndex) {
      if (isResolving || isGameOver) return;
      if (dropsLeft <= 0) return;

      // find the highest free row from the bottom
      let targetRow = -1;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (!board[r][colIndex]) {
          targetRow = r;
          break;
        }
      }

      if (targetRow === -1) {
        setStatus("That lane is full. Try another.");
        playFailSound();
        return;
      }

      // place tile
      board[targetRow][colIndex] = {
        color: nextColorId,
        special: null
      };
      lastSpawn = { row: targetRow, col: colIndex };
      dropsLeft -= 1;

      playDropSound();
      chooseNextColor();
      renderBoard();
      updateHud();
      setStatus("");

      resolveBoard();

      if (dropsLeft <= 0 && !isGameOver) {
        setStatus("No drops left. Clear as many rows as you can.");
      }
    }

    function checkLevelEnd() {
      if (isResolving || isGameOver) return;

      const level = LEVELS[currentLevelIndex];

      // Check if stack reached the top (any tile in row 0)
      const stackTouchingTop = board[0].some((tile) => tile !== null);

      if (score >= level.targetScore) {
        isGameOver = true;
        playLevelUpSound();
        openModal(
          "Level Complete",
          `${level.name} cleared with a score of ${score}.`
        );
        return;
      }

      if (dropsLeft <= 0 || stackTouchingTop) {
        isGameOver = true;
        playFailSound();
        const reason = stackTouchingTop
          ? "The stack reached the top."
          : "No drops left.";
        openModal(
          "Stack Over",
          `${reason} Final score: ${score}. Target was ${level.targetScore}.`
        );
      }
    }

    function openModal(title, body) {
      modalTitle.textContent = title;
      modalBody.textContent = body;
      modalBackdrop.classList.remove("hidden");
    }

    function closeModal() {
      modalBackdrop.classList.add("hidden");
    }

    function restartLevel() {
      closeModal();
      startLevel(currentLevelIndex);
    }

    function goToNextLevel() {
      closeModal();
      const nextIndex =
        currentLevelIndex + 1 < LEVELS.length ? currentLevelIndex + 1 : 0;
      startLevel(nextIndex);
    }

    function startLevel(index) {
      const level = LEVELS[index];
      currentLevelIndex = index;
      score = 0;
      dropsLeft = level.maxDrops;
      rowsClearedTotal = 0;
      currentChain = 1.0;
      bestChain = 1.0;
      isResolving = false;
      isGameOver = false;
      lastSpawn = null;

      makeEmptyBoard();
      chooseNextColor();
      renderBoard();
      updateHud();

      setStatus(
        `${level.name} · Reach ${level.targetScore} points in ${level.maxDrops} drops.`
      );
    }

    // --- Wiring -------------------------------------------------------------

    laneButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const col = parseInt(btn.dataset.lane, 10);
        dropBlockInLane(col);
      });
    });

    btnRestart.addEventListener("click", () => {
      restartLevel();
    });

    btnNext.addEventListener("click", () => {
      goToNextLevel();
    });

    modalRestart.addEventListener("click", () => {
      restartLevel();
    });

    modalNext.addEventListener("click", () => {
      goToNextLevel();
    });

    modalBackdrop.addEventListener("click", (evt) => {
      if (evt.target === modalBackdrop) {
        closeModal();
      }
    });

    // First tap to unlock audio on some devices
    document.body.addEventListener(
      "click",
      () => {
        getAudioCtx();
      },
      { once: true }
    );

    // --- Boot ---------------------------------------------------------------

    startLevel(0);
  </script>
</body>
</html>
